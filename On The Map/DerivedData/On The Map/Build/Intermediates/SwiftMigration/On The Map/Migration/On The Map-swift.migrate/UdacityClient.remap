[
 {
  "file": "/Users/Brwong/Desktop/iOS Apps/On The Map/On The Map/UdacityClient.swift",
  "offset": 1054,
  "remove": 3535,
  "text": "do {\n            request.HTTPBody = try NSJSONSerialization.dataWithJSONObject(jsonBody, options: [])\n        } catch var error as NSError {\n            jsonifyError = error\n            request.HTTPBody = nil\n        }\n        \n        /* Make the request */\n        let task = session.dataTaskWithRequest(request) {data, response, downloadError in\n            \n            /*  Parse the data and use the data (happens in completion handler) */\n            if let error = downloadError {\n                //println(error)\n                completionHandler(result: nil, error: downloadError)\n            } else {\n                //Need to cut off first 5 chars for security purposes\n                let newData = data.subdataWithRange(NSMakeRange(5, data.length - 5)) /* subset response data! */\n                \n                //Use helper method to parse JSON and return usable data to this functions completion handler\n                UdacityClient.parseJSONWithCompletionHandler(newData, completionHandler: completionHandler)\n            }\n        }\n        \n        /* Start the request */\n        task.resume()\n        \n        return task\n    }\n    \n    func taskForLogout(){\n            let request = NSMutableURLRequest(URL: NSURL(string: Methods.UdacityBaseURLSecure)!)\n            request.HTTPMethod = \"DELETE\"\n            var xsrfCookie: NSHTTPCookie? = nil\n            let sharedCookieStorage = NSHTTPCookieStorage.sharedHTTPCookieStorage()\n            for cookie in sharedCookieStorage.cookies as! [NSHTTPCookie] {\n                if cookie.name == \"XSRF-TOKEN\" { xsrfCookie = cookie }\n            }\n            if let xsrfCookie = xsrfCookie {\n                request.setValue(xsrfCookie.value, forHTTPHeaderField: \"X-XSRF-TOKEN\")\n            }\n            let session = NSURLSession.sharedSession()\n            let task = session.dataTaskWithRequest(request) { data, response, error in\n                if error != nil {\n                    print(error)\n                    return\n                }\n                let newData = data.subdataWithRange(NSMakeRange(5, data.length - 5)) /* subset response data! */\n                print(\"Logout successful\")\n            }\n            task.resume()\n    }\n    \n    func taskForGetUserData(completionHandler: (result: AnyObject!, error: NSError?) -> Void) -> NSURLSessionDataTask {\n        \n        let urlString = Methods.GetPublicData + self.userID!\n        let url = NSURL(string: urlString)!\n        let request = NSURLRequest(URL: url)\n        let task = session.dataTaskWithRequest(request) {data, response, downloadError in\n            \n            /*  Parse the data and use the data (happens in completion handler) */\n            if let error = downloadError {\n                print(\"Get Error client\")\n                completionHandler(result: nil, error: downloadError)\n            } else {\n                //Need to cut off first 5 chars for security purposes\n                let newData = data.subdataWithRange(NSMakeRange(5, data.length - 5)) /* subset response data! */\n                UdacityClient.parseJSONWithCompletionHandler(newData, completionHandler: completionHandler)\n            }\n        }\n        task.resume()\n        \n        return task\n    }\n    \n    /* Helper: Given raw JSON, return a usable Foundation object */\n    class func parseJSONWithCompletionHandler(data: NSData, completionHandler: (result: AnyObject!, error: NSError?) -> Void) {\n        \n        var parsingError: NSError? = nil\n        \n        let parsedResult: AnyObject?\n        do {\n            parsedResult = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.AllowFragments)\n        } catch let error as NSError {\n            parsingError = error\n            parsedResult = nil\n        }",
 }
]
