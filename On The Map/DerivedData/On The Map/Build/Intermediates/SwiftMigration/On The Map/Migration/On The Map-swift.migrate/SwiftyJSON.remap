[
 {
  "file": "/Users/Brwong/Desktop/iOS Apps/On The Map/SwiftyJSON.swift",
  "offset": 1797,
  "remove": 34255,
  "text": "- parameter data:  The NSData used to convert to json.Top level object in data is an NSArray or NSDictionary\n    - parameter opt:   The JSON serialization reading options. `.AllowFragments` by default.\n    - parameter error: error The NSErrorPointer used to return the error. `nil` by default.\n    \n    - returns: The created JSON\n    */\n    public init(data:NSData, options opt: NSJSONReadingOptions = .AllowFragments, error: NSErrorPointer = nil) {\n        do {\n            let object: AnyObject = try NSJSONSerialization.JSONObjectWithData(data, options: opt)\n            self.init(object)\n        } catch let error1 as NSError {\n            error.memory = error1\n            self.init(NSNull())\n        }\n    }\n    \n    /**\n    Creates a JSON using the object.\n    \n    - parameter object:  The object must have the following properties: All objects are NSString/String, NSNumber/Int/Float/Double/Bool, NSArray/Array, NSDictionary/Dictionary, or NSNull; All dictionary keys are NSStrings/String; NSNumbers are not NaN or infinity.\n    \n    - returns: The created JSON\n    */\n    public init(_ object: AnyObject) {\n        self.object = object\n    }\n\n    /**\n    Creates a JSON from a [JSON]\n    \n    - parameter jsonArray: A Swift array of JSON objects\n    \n    - returns: The created JSON\n    */\n    public init(_ jsonArray:[JSON]) {\n        self.init(jsonArray.map { $0.object })\n    }\n\n    /**\n    Creates a JSON from a [String: JSON]\n    \n    - parameter jsonDictionary: A Swift dictionary of JSON objects\n    \n    - returns: The created JSON\n    */\n    public init(_ jsonDictionary:[String: JSON]) {\n        var dictionary = [String: AnyObject]()\n        for (key, json) in jsonDictionary {\n            dictionary[key] = json.object\n        }\n        self.init(dictionary)\n    }\n\n    /// Private object\n    private var _object: AnyObject = NSNull()\n    /// Private type\n    private var _type: Type = .Null\n    /// prviate error\n    private var _error: NSError?\n\n    /// Object in JSON\n    public var object: AnyObject {\n        get {\n            return _object\n        }\n        set {\n            _object = newValue\n            switch newValue {\n            case let number as NSNumber:\n                if number.isBool {\n                    _type = .Bool\n                } else {\n                    _type = .Number\n                }\n            case let string as NSString:\n                _type = .String\n            case let null as NSNull:\n                _type = .Null\n            case let array as [AnyObject]:\n                _type = .Array\n            case let dictionary as [String : AnyObject]:\n                _type = .Dictionary\n            default:\n                _type = .Unknown\n                _object = NSNull()\n                _error = NSError(domain: ErrorDomain, code: ErrorUnsupportedType, userInfo: [NSLocalizedDescriptionKey: \"It is a unsupported type\"])\n            }\n        }\n    }\n    \n    /// json type\n    public var type: Type { get { return _type } }\n\n    /// Error in JSON\n    public var error: NSError? { get { return self._error } }\n    \n    /// The static null json\n    public static var nullJSON: JSON { get { return JSON(NSNull()) } }\n\n}\n\n// MARK: - SequenceType\nextension JSON : Swift.SequenceType {\n    \n    /// If `type` is `.Array` or `.Dictionary`, return `array.empty` or `dictonary.empty` otherwise return `false`.\n    public var isEmpty: Bool {\n        get {\n            switch self.type {\n            case .Array:\n                return (self.object as! [AnyObject]).isEmpty\n            case .Dictionary:\n                return (self.object as! [String : AnyObject]).isEmpty\n            default:\n                return false\n            }\n        }\n    }\n    \n    /// If `type` is `.Array` or `.Dictionary`, return `array.count` or `dictonary.count` otherwise return `0`.\n    public var count: Int {\n        get {\n            switch self.type {\n            case .Array:\n                return (self.object as! [AnyObject]).count\n            case .Dictionary:\n                return (self.object as! [String : AnyObject]).count\n            default:\n                return 0\n            }\n        }\n    }\n    \n    /**\n    If `type` is `.Array` or `.Dictionary`, return a generator over the elements like `Array` or `Dictionary`, otherwise return a generator over empty.\n    \n    - returns: Return a *generator* over the elements of this *sequence*.\n    */\n    public func generate() -> AnyGenerator<(String, JSON)> {\n        switch self.type {\n        case .Array:\n            let array_ = object as! [AnyObject]\n            var generate_ = array_.generate()\n            var index_: Int = 0\n            return anyGenerator {\n                if let element_: AnyObject = generate_.next() {\n                    return (\"\\(index_++)\", JSON(element_))\n                } else {\n                    return nil\n                }\n            }\n        case .Dictionary:\n            let dictionary_ = object as! [String : AnyObject]\n            var generate_ = dictionary_.generate()\n            return anyGenerator {\n                if let (key_, value_): (String, AnyObject) = generate_.next() {\n                    return (key_, JSON(value_))\n                } else {\n                    return nil\n                }\n            }\n        default:\n            return anyGenerator {\n                return nil\n            }\n        }\n    }\n}\n\n// MARK: - Subscript\n\n/**\n*  To mark both String and Int can be used in subscript.\n*/\npublic protocol SubscriptType {}\n\nextension Int: SubscriptType {}\n\nextension String: SubscriptType {}\n\nextension JSON {\n    \n    /// If `type` is `.Array`, return json which's object is `array[index]`, otherwise return null json with error.\n    private subscript(index index: Int) -> JSON {\n        get {\n            \n            if self.type != .Array {\n                var errorResult_ = JSON.nullJSON\n                errorResult_._error = self._error ?? NSError(domain: ErrorDomain, code: ErrorWrongType, userInfo: [NSLocalizedDescriptionKey: \"Array[\\(index)] failure, It is not an array\"])\n                return errorResult_\n            }\n            \n            let array_ = self.object as! [AnyObject]\n\n            if index >= 0 && index < array_.count {\n                return JSON(array_[index])\n            }\n            \n            var errorResult_ = JSON.nullJSON\n            errorResult_._error = NSError(domain: ErrorDomain, code:ErrorIndexOutOfBounds , userInfo: [NSLocalizedDescriptionKey: \"Array[\\(index)] is out of bounds\"])\n            return errorResult_\n        }\n        set {\n            if self.type == .Array {\n                var array_ = self.object as! [AnyObject]\n                if array_.count > index {\n                    array_[index] = newValue.object\n                    self.object = array_\n                }\n            }\n        }\n    }\n\n    /// If `type` is `.Dictionary`, return json which's object is `dictionary[key]` , otherwise return null json with error.\n    private subscript(key key: String) -> JSON {\n        get {\n            var returnJSON = JSON.nullJSON\n            if self.type == .Dictionary {\n                let dictionary_ = self.object as! [String : AnyObject]\n                if let object_: AnyObject = dictionary_[key] {\n                    returnJSON = JSON(object_)\n                } else {\n                    returnJSON._error = NSError(domain: ErrorDomain, code: ErrorNotExist, userInfo: [NSLocalizedDescriptionKey: \"Dictionary[\\\"\\(key)\\\"] does not exist\"])\n                }\n            } else {\n                returnJSON._error = self._error ?? NSError(domain: ErrorDomain, code: ErrorWrongType, userInfo: [NSLocalizedDescriptionKey: \"Dictionary[\\\"\\(key)\\\"] failure, It is not an dictionary\"])\n            }\n            return returnJSON\n        }\n        set {\n            if self.type == .Dictionary {\n                var dictionary_ = self.object as! [String : AnyObject]\n                dictionary_[key] = newValue.object\n                self.object = dictionary_\n            }\n        }\n    }\n    \n    /// If `sub` is `Int`, return `subscript(index:)`; If `sub` is `String`,  return `subscript(key:)`.\n    private subscript(sub sub: SubscriptType) -> JSON {\n        get {\n            if sub is String {\n                return self[key:sub as! String]\n            } else {\n                return self[index:sub as! Int]\n            }\n        }\n        set {\n            if sub is String {\n                self[key:sub as! String] = newValue\n            } else {\n                self[index:sub as! Int] = newValue\n            }\n        }\n    }\n    \n    /**\n    Find a json in the complex data structuresby using the Int/String's array.\n    \n    - parameter path: The target json's path. Example: \n                   \n            let json = JSON[data]\n            let path = [9,\"list\",\"person\",\"name\"]\n            let name = json[path]\n    \n            The same as: let name = json[9][\"list\"][\"person\"][\"name\"]\n    \n    - returns: Return a json found by the path or a null json with error\n    */\n    public subscript(path: [SubscriptType]) -> JSON {\n        get {\n            if path.count == 0 {\n                return JSON.nullJSON\n            }\n            \n            var next = self\n            for sub in path {\n                next = next[sub:sub]\n            }\n            return next\n        }\n        set {\n            \n            switch path.count {\n            case 0: return\n            case 1: self[sub:path[0]] = newValue\n            default:\n                var last = newValue\n                var newPath = path\n                newPath.removeLast()\n                for sub in Array(path.reverse()) {\n                    var previousLast = self[newPath]\n                    previousLast[sub:sub] = last\n                    last = previousLast\n                    if newPath.count <= 1 {\n                        break\n                    }\n                    newPath.removeLast()\n                }\n                self[sub:newPath[0]] = last\n            }\n        }\n    }\n    \n    /**\n    Find a json in the complex data structuresby using the Int/String's array.\n    \n    - parameter path: The target json's path. Example:\n    \n            let name = json[9,\"list\",\"person\",\"name\"]\n    \n            The same as: let name = json[9][\"list\"][\"person\"][\"name\"]\n    \n    - returns: Return a json found by the path or a null json with error\n    */\n    public subscript(path: SubscriptType...) -> JSON {\n        get {\n            return self[path]\n        }\n        set {\n            self[path] = newValue\n        }\n    }\n}\n\n// MARK: - LiteralConvertible\n\nextension JSON: Swift.StringLiteralConvertible {\n\t\n\tpublic init(stringLiteral value: StringLiteralType) {\n\t\tself.init(value)\n\t}\n\t\n\tpublic init(extendedGraphemeClusterLiteral value: StringLiteralType) {\n\t\tself.init(value)\n\t}\n\t\n\tpublic init(unicodeScalarLiteral value: StringLiteralType) {\n\t\tself.init(value)\n\t}\n}\n\nextension JSON: Swift.IntegerLiteralConvertible {\n\n\tpublic init(integerLiteral value: IntegerLiteralType) {\n\t\tself.init(value)\n\t}\n}\n\nextension JSON: Swift.BooleanLiteralConvertible {\n\t\n\tpublic init(booleanLiteral value: BooleanLiteralType) {\n\t\tself.init(value)\n\t}\n}\n\nextension JSON: Swift.FloatLiteralConvertible {\n\t\n\tpublic init(floatLiteral value: FloatLiteralType) {\n\t\tself.init(value)\n\t}\n}\n\nextension JSON: Swift.DictionaryLiteralConvertible {\n\t\n\tpublic init(dictionaryLiteral elements: (String, AnyObject)...) {\n\t\tvar dictionary_ = [String : AnyObject]()\n\t\tfor (key_, value) in elements {\n\t\t\tdictionary_[key_] = value\n\t\t}\n\t\tself.init(dictionary_)\n\t}\n}\n\nextension JSON: Swift.ArrayLiteralConvertible {\n\t\n\tpublic init(arrayLiteral elements: AnyObject...) {\n\t\tself.init(elements)\n\t}\n}\n\nextension JSON: Swift.NilLiteralConvertible {\n\t\n\tpublic init(nilLiteral: ()) {\n\t\tself.init(NSNull())\n\t}\n}\n\n// MARK: - Raw\n\nextension JSON: Swift.RawRepresentable {\n\t\n\tpublic init?(rawValue: AnyObject) {\n\t\tif JSON(rawValue).type == .Unknown {\n\t\t\treturn nil\n\t\t} else {\n\t\t\tself.init(rawValue)\n\t\t}\n\t}\n\t\n\tpublic var rawValue: AnyObject {\n\t\treturn self.object\n\t}\n\n    public func rawData(options opt: NSJSONWritingOptions = NSJSONWritingOptions(rawValue: 0)) throws -> NSData {\n        return try NSJSONSerialization.dataWithJSONObject(self.object, options: opt)\n    }\n    \n    public func rawString(encoding: UInt = NSUTF8StringEncoding, options opt: NSJSONWritingOptions = .PrettyPrinted) -> String? {\n        switch self.type {\n        case .Array, .Dictionary:\n            do {\n                let data = try self.rawData(options: opt)\n                return NSString(data: data, encoding: encoding) as? String\n            } catch _ {\n                return nil\n            }\n        case .String:\n            return (self.object as! String)\n        case .Number:\n            return (self.object as! NSNumber).stringValue\n        case .Bool:\n            return (self.object as! Bool).description\n        case .Null:\n            return \"null\"\n        default:\n            return nil\n        }\n    }\n}\n\n// MARK: - Printable, DebugPrintable\n\nextension JSON: Swift.Printable, Swift.DebugPrintable {\n    \n    public var description: String {\n        if let string = self.rawString(options:.PrettyPrinted) {\n            return string\n        } else {\n            return \"unknown\"\n        }\n    }\n    \n    public var debugDescription: String {\n        return description\n    }\n}\n\n// MARK: - Array\n\nextension JSON {\n\n    //Optional [JSON]\n    public var array: [JSON]? {\n        get {\n            if self.type == .Array {\n                return (self.object as! [AnyObject]).map{ JSON($0) }\n            } else {\n                return nil\n            }\n        }\n    }\n    \n    //Non-optional [JSON]\n    public var arrayValue: [JSON] {\n        get {\n            return self.array ?? []\n        }\n    }\n    \n    //Optional [AnyObject]\n    public var arrayObject: [AnyObject]? {\n        get {\n            switch self.type {\n            case .Array:\n                return self.object as? [AnyObject]\n            default:\n                return nil\n            }\n        }\n        set {\n            if newValue != nil {\n                self.object = NSMutableArray(array: newValue!, copyItems: true)\n            } else {\n                self.object = NSNull()\n            }\n        }\n    }\n}\n\n// MARK: - Dictionary\n\nextension JSON {\n    \n    private func _map<Key:Hashable ,Value, NewValue>(source: [Key: Value], transform: Value -> NewValue) -> [Key: NewValue] {\n        var result = [Key: NewValue](minimumCapacity:source.count)\n        for (key,value) in source {\n            result[key] = transform(value)\n        }\n        return result\n    }\n\n    //Optional [String : JSON]\n    public var dictionary: [String : JSON]? {\n        get {\n            if self.type == .Dictionary {\n                return _map(self.object as! [String : AnyObject]){ JSON($0) }\n            } else {\n                return nil\n            }\n        }\n    }\n    \n    //Non-optional [String : JSON]\n    public var dictionaryValue: [String : JSON] {\n        get {\n            return self.dictionary ?? [:]\n        }\n    }\n    \n    //Optional [String : AnyObject]\n    public var dictionaryObject: [String : AnyObject]? {\n        get {\n            switch self.type {\n            case .Dictionary:\n                return self.object as? [String : AnyObject]\n            default:\n                return nil\n            }\n        }\n        set {\n            if newValue != nil {\n                self.object = NSMutableDictionary(dictionary: newValue!, copyItems: true)\n            } else {\n                self.object = NSNull()\n            }\n        }\n    }\n}\n\n// MARK: - Bool\n\nextension JSON: Swift.BooleanType {\n    \n    //Optional bool\n    public var bool: Bool? {\n        get {\n            switch self.type {\n            case .Bool:\n                return self.object.boolValue\n            default:\n                return nil\n            }\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(bool: newValue!)\n            } else {\n                self.object = NSNull()\n            }\n        }\n    }\n\n    //Non-optional bool\n    public var boolValue: Bool {\n        get {\n            switch self.type {\n            case .Bool, .Number, .String:\n                return self.object.boolValue\n            default:\n                return false\n            }\n        }\n        set {\n            self.object = NSNumber(bool: newValue)\n        }\n    }\n}\n\n// MARK: - String\n\nextension JSON {\n\n    //Optional string\n    public var string: String? {\n        get {\n            switch self.type {\n            case .String:\n                return self.object as? String\n            default:\n                return nil\n            }\n        }\n        set {\n            if newValue != nil {\n                self.object = NSString(string:newValue!)\n            } else {\n                self.object = NSNull()\n            }\n        }\n    }\n    \n    //Non-optional string\n    public var stringValue: String {\n        get {\n            switch self.type {\n            case .String:\n                return self.object as! String\n            case .Number:\n                return self.object.stringValue\n            case .Bool:\n                return (self.object as! Bool).description\n            default:\n                return \"\"\n            }\n        }\n        set {\n            self.object = NSString(string:newValue)\n        }\n    }\n}\n\n// MARK: - Number\nextension JSON {\n    \n    //Optional number\n    public var number: NSNumber? {\n        get {\n            switch self.type {\n            case .Number, .Bool:\n                return self.object as? NSNumber\n            default:\n                return nil\n            }\n        }\n        set {\n            self.object = newValue?.copy() ?? NSNull()\n        }\n    }\n    \n    //Non-optional number\n    public var numberValue: NSNumber {\n        get {\n            switch self.type {\n            case .String:\n                let scanner = NSScanner(string: self.object as! String)\n                if scanner.scanDouble(nil){\n                    if (scanner.atEnd) {\n                        return NSNumber(double:(self.object as! NSString).doubleValue)\n                    }\n                }\n                return NSNumber(double: 0.0)\n            case .Number, .Bool:\n                return self.object as! NSNumber\n            default:\n                return NSNumber(double: 0.0)\n            }\n        }\n        set {\n            self.object = newValue.copy()\n        }\n    }\n}\n\n//MARK: - Null\nextension JSON {\n \n    public var null: NSNull? {\n        get {\n            switch self.type {\n            case .Null:\n                return NSNull()\n            default:\n                return nil\n            }\n        }\n        set {\n            self.object = NSNull()\n        }\n    }\n}\n\n//MARK: - URL\nextension JSON {\n    \n    //Optional URL\n    public var URL: NSURL? {\n        get {\n            switch self.type {\n            case .String:\n                if let encodedString_ = self.object.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n                    return NSURL(string: encodedString_)\n                } else {\n                    return nil\n                }\n            default:\n                return nil\n            }\n        }\n        set {\n            self.object = newValue?.absoluteString ?? NSNull()\n        }\n    }\n}\n\n// MARK: - Int, Double, Float, Int8, Int16, Int32, Int64\n\nextension JSON {\n    \n    public var double: Double? {\n        get {\n            return self.number?.doubleValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(double: newValue!)\n            } else {\n                self.object = NSNull()\n            }\n        }\n    }\n    \n    public var doubleValue: Double {\n        get {\n            return self.numberValue.doubleValue\n        }\n        set {\n            self.object = NSNumber(double: newValue)\n        }\n    }\n    \n    public var float: Float? {\n        get {\n            return self.number?.floatValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(float: newValue!)\n            } else {\n                self.object = NSNull()\n            }\n        }\n    }\n    \n    public var floatValue: Float {\n        get {\n            return self.numberValue.floatValue\n        }\n        set {\n            self.object = NSNumber(float: newValue)\n        }\n    }\n    \n    public var int: Int? {\n        get {\n            return self.number?.longValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(integer: newValue!)\n            } else {\n                self.object = NSNull()\n            }\n        }\n    }\n    \n    public var intValue: Int {\n        get {\n            return self.numberValue.integerValue\n        }\n        set {\n            self.object = NSNumber(integer: newValue)\n        }\n    }\n    \n    public var uInt: UInt? {\n        get {\n            return self.number?.unsignedLongValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(unsignedLong: newValue!)\n            } else {\n                self.object = NSNull()\n            }\n        }\n    }\n    \n    public var uIntValue: UInt {\n        get {\n            return self.numberValue.unsignedLongValue\n        }\n        set {\n            self.object = NSNumber(unsignedLong: newValue)\n        }\n    }\n\n    public var int8: Int8? {\n        get {\n            return self.number?.charValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(char: newValue!)\n            } else {\n                self.object =  NSNull()\n            }\n        }\n    }\n    \n    public var int8Value: Int8 {\n        get {\n            return self.numberValue.charValue\n        }\n        set {\n            self.object = NSNumber(char: newValue)\n        }\n    }\n    \n    public var uInt8: UInt8? {\n        get {\n            return self.number?.unsignedCharValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(unsignedChar: newValue!)\n            } else {\n                self.object =  NSNull()\n            }\n        }\n    }\n    \n    public var uInt8Value: UInt8 {\n        get {\n            return self.numberValue.unsignedCharValue\n        }\n        set {\n            self.object = NSNumber(unsignedChar: newValue)\n        }\n    }\n    \n    public var int16: Int16? {\n        get {\n            return self.number?.shortValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(short: newValue!)\n            } else {\n                self.object =  NSNull()\n            }\n        }\n    }\n    \n    public var int16Value: Int16 {\n        get {\n            return self.numberValue.shortValue\n        }\n        set {\n            self.object = NSNumber(short: newValue)\n        }\n    }\n    \n    public var uInt16: UInt16? {\n        get {\n            return self.number?.unsignedShortValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(unsignedShort: newValue!)\n            } else {\n                self.object =  NSNull()\n            }\n        }\n    }\n    \n    public var uInt16Value: UInt16 {\n        get {\n            return self.numberValue.unsignedShortValue\n        }\n        set {\n            self.object = NSNumber(unsignedShort: newValue)\n        }\n    }\n\n    public var int32: Int32? {\n        get {\n            return self.number?.intValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(int: newValue!)\n            } else {\n                self.object =  NSNull()\n            }\n        }\n    }\n    \n    public var int32Value: Int32 {\n        get {\n            return self.numberValue.intValue\n        }\n        set {\n            self.object = NSNumber(int: newValue)\n        }\n    }\n    \n    public var uInt32: UInt32? {\n        get {\n            return self.number?.unsignedIntValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(unsignedInt: newValue!)\n            } else {\n                self.object =  NSNull()\n            }\n        }\n    }\n    \n    public var uInt32Value: UInt32 {\n        get {\n            return self.numberValue.unsignedIntValue\n        }\n        set {\n            self.object = NSNumber(unsignedInt: newValue)\n        }\n    }\n    \n    public var int64: Int64? {\n        get {\n            return self.number?.longLongValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(longLong: newValue!)\n            } else {\n                self.object =  NSNull()\n            }\n        }\n    }\n    \n    public var int64Value: Int64 {\n        get {\n            return self.numberValue.longLongValue\n        }\n        set {\n            self.object = NSNumber(longLong: newValue)\n        }\n    }\n    \n    public var uInt64: UInt64? {\n        get {\n            return self.number?.unsignedLongLongValue\n        }\n        set {\n            if newValue != nil {\n                self.object = NSNumber(unsignedLongLong: newValue!)\n            } else {\n                self.object =  NSNull()\n            }\n        }\n    }\n    \n    public var uInt64Value: UInt64 {\n        get {\n            return self.numberValue.unsignedLongLongValue\n        }\n        set {\n            self.object = NSNumber(unsignedLongLong: newValue)\n        }\n    }\n}\n\n//MARK: - Comparable\nextension JSON: Swift.Comparable {}\n\npublic func ==(lhs: JSON, rhs: JSON) -> Bool {\n    \n    switch (lhs.type, rhs.type) {\n    case (.Number, .Number):\n        return (lhs.object as! NSNumber) == (rhs.object as! NSNumber)\n    case (.String, .String):\n        return (lhs.object as! String) == (rhs.object as! String)\n    case (.Bool, .Bool):\n        return (lhs.object as! Bool) == (rhs.object as! Bool)\n    case (.Array, .Array):\n        return (lhs.object as! NSArray) == (rhs.object as! NSArray)\n    case (.Dictionary, .Dictionary):\n        return (lhs.object as! NSDictionary) == (rhs.object as! NSDictionary)\n    case (.Null, .Null):\n        return true\n    default:\n        return false\n    }\n}\n\npublic func <=(lhs: JSON, rhs: JSON) -> Bool {\n    \n    switch (lhs.type, rhs.type) {\n    case (.Number, .Number):\n        return (lhs.object as! NSNumber) <= (rhs.object as! NSNumber)\n    case (.String, .String):\n        return (lhs.object as! String) <= (rhs.object as! String)\n    case (.Bool, .Bool):\n        return (lhs.object as! Bool) == (rhs.object as! Bool)\n    case (.Array, .Array):\n        return (lhs.object as! NSArray) == (rhs.object as! NSArray)\n    case (.Dictionary, .Dictionary):\n        return (lhs.object as! NSDictionary) == (rhs.object as! NSDictionary)\n    case (.Null, .Null):\n        return true\n    default:\n        return false\n    }\n}\n\npublic func >=(lhs: JSON, rhs: JSON) -> Bool {\n    \n    switch (lhs.type, rhs.type) {\n    case (.Number, .Number):\n        return (lhs.object as! NSNumber) >= (rhs.object as! NSNumber)\n    case (.String, .String):\n        return (lhs.object as! String) >= (rhs.object as! String)\n    case (.Bool, .Bool):\n        return (lhs.object as! Bool) == (rhs.object as! Bool)\n    case (.Array, .Array):\n        return (lhs.object as! NSArray) == (rhs.object as! NSArray)\n    case (.Dictionary, .Dictionary):\n        return (lhs.object as! NSDictionary) == (rhs.object as! NSDictionary)\n    case (.Null, .Null):\n        return true\n    default:\n        return false\n    }\n}\n\npublic func >(lhs: JSON, rhs: JSON) -> Bool {\n    \n    switch (lhs.type, rhs.type) {\n    case (.Number, .Number):\n        return (lhs.object as! NSNumber) > (rhs.object as! NSNumber)\n    case (.String, .String):\n        return (lhs.object as! String) > (rhs.object as! String)\n    default:\n        return false\n    }\n}\n\npublic func <(lhs: JSON, rhs: JSON) -> Bool {\n    \n    switch (lhs.type, rhs.type) {\n    case (.Number, .Number):\n        return (lhs.object as! NSNumber) < (rhs.object as! NSNumber)\n    case (.String, .String):\n        return (lhs.object as! String) < (rhs.object as! String)\n    default:\n        return false\n    }\n}\n\nprivate let trueNumber = NSNumber(bool: true)\nprivate let falseNumber = NSNumber(bool: false)\nprivate let trueObjCType = String.fromCString(trueNumber.objCType)\nprivate let falseObjCType = String.fromCString(falseNumber.objCType)\n\n// MARK: - NSNumber: Comparable\n\nextension NSNumber: Swift.Comparable {\n    var isBool:Bool {\n        get {\n            let objCType = String.fromCString(self.objCType)\n            if (self.compare(trueNumber) == NSComparisonResult.OrderedSame &&  objCType == trueObjCType) ||  (self.compare(falseNumber) == NSComparisonResult.OrderedSame && objCType == falseObjCType){\n                return true\n            } else {\n                return false\n            }\n        }\n    }\n}\n\npublic func ==(lhs: NSNumber, rhs: NSNumber) -> Bool {\n    switch (lhs.isBool, rhs.isBool) {\n    case (false, true):\n        return false\n    case (true, false):\n        return false\n    default:\n        return lhs.compare(rhs) == NSComparisonResult.OrderedSame\n    }\n}\n\npublic func !=(lhs: NSNumber, rhs: NSNumber) -> Bool {\n    return !(lhs == rhs)\n}\n\npublic func <(lhs: NSNumber, rhs: NSNumber) -> Bool {\n    \n    switch (lhs.isBool, rhs.isBool) {\n    case (false, true):\n        return false\n    case (true, false):\n        return false\n    default:\n        return lhs.compare(rhs) == NSComparisonResult.OrderedAscending\n    }\n}\n\npublic func >(lhs: NSNumber, rhs: NSNumber) -> Bool {\n    \n    switch (lhs.isBool, rhs.isBool) {\n    case (false, true):\n        return false\n    case (true, false):\n        return false\n    default:\n        return lhs.compare(rhs) == NSComparisonResult.OrderedDescending\n    }\n}\n\npublic func <=(lhs: NSNumber, rhs: NSNumber) -> Bool {\n\n    switch (lhs.isBool, rhs.isBool) {\n    case (false, true):\n        return false\n    case (true, false):\n        return false\n    default:\n        return lhs.compare(rhs) != NSComparisonResult.OrderedDescending\n    }\n}\n\npublic func >=(lhs: NSNumber, rhs: NSNumber) -> Bool {\n\n    switch (lhs.isBool, rhs.isBool) {\n    case (false, true):\n        return false\n    case (true, false):\n        return false\n    default:\n        return lhs.compare(rhs) != NSComparisonResult.OrderedAscending\n    }\n}\n\n//MARK:- Unavailable\n\n@available(*, unavailable, renamed=\"JSON\")\npublic typealias JSONValue = JSON\n\nextension JSON {\n    \n    @available(*, unavailable, message=\"use 'init(_ object:AnyObject)' instead\")\n    public init(object: AnyObject) {\n        self = JSON(object)\n    }\n    \n    @available(*, unavailable, renamed=\"dictionaryObject\")\n    public var dictionaryObjects: [String : AnyObject]? {\n        get { return self.dictionaryObject }\n    }\n    \n    @available(*, unavailable, renamed=\"arrayObject\")\n    public var arrayObjects: [AnyObject]? {\n        get { return self.arrayObject }\n    }\n    \n    @available(*, unavailable, renamed=\"int8\")\n    public var char: Int8? {\n        get {\n            return self.number?.charValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"int8Value\")\n    public var charValue: Int8 {\n        get {\n            return self.numberValue.charValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"uInt8\")\n    public var unsignedChar: UInt8? {\n        get{\n            return self.number?.unsignedCharValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"uInt8Value\")\n    public var unsignedCharValue: UInt8 {\n        get{\n            return self.numberValue.unsignedCharValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"int16\")\n    public var short: Int16? {\n        get{\n            return self.number?.shortValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"int16Value\")\n    public var shortValue: Int16 {\n        get{\n            return self.numberValue.shortValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"uInt16\")\n    public var unsignedShort: UInt16? {\n        get{\n            return self.number?.unsignedShortValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"uInt16Value\")\n    public var unsignedShortValue: UInt16 {\n        get{\n            return self.numberValue.unsignedShortValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"int\")\n    public var long: Int? {\n        get{\n            return self.number?.longValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"intValue\")\n    public var longValue: Int {\n        get{\n            return self.numberValue.longValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"uInt\")\n    public var unsignedLong: UInt? {\n        get{\n            return self.number?.unsignedLongValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"uIntValue\")\n    public var unsignedLongValue: UInt {\n        get{\n            return self.numberValue.unsignedLongValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"int64\")\n    public var longLong: Int64? {\n        get{\n            return self.number?.longLongValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"int64Value\")\n    public var longLongValue: Int64 {\n        get{\n            return self.numberValue.longLongValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"uInt64\")\n    public var unsignedLongLong: UInt64? {\n        get{\n            return self.number?.unsignedLongLongValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"uInt64Value\")\n    public var unsignedLongLongValue: UInt64 {\n        get{\n            return self.numberValue.unsignedLongLongValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"int\")\n    public var integer: Int? {\n        get {\n            return self.number?.integerValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"intValue\")\n    public var integerValue: Int {\n        get {\n            return self.numberValue.integerValue\n        }\n    }\n    \n    @available(*, unavailable, renamed=\"uInt\")\n    public var unsignedInteger: Int? {\n        get {\n            return self.number?.unsignedIntegerValue\n        }\n    }\n    \n    @available",
 }
]
